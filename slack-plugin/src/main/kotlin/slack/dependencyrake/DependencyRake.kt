/*
 * Copyright (C) 2022 Slack Technologies, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package slack.dependencyrake

import com.autonomousapps.AbstractPostProcessingTask
import com.autonomousapps.advice.Advice
import com.autonomousapps.advice.Dependency
import com.autonomousapps.advice.PluginAdvice
import java.io.File
import javax.inject.Inject
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property
import org.gradle.api.provider.ProviderFactory
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction

private const val IGNORE_COMMENT = "// dependency-rake=ignore"

// Dependencies that act as a facade for multiple transitives that aren't usually intended to be
// directly depended on.
private val FACADE_DEPENDENCIES =
  setOf(
    "androidx.paging:paging-runtime",
    "androidx.lifecycle:lifecycle-runtime",
    "com.android.tools.lint:lint",
    "com.android.tools.lint:lint-api",
    "com.android.tools.lint:lint-checks",
    "com.android.tools.lint:lint-tests",
    "com.birbit:android-priority-jobqueue",
    "com.bugsnag:bugsnag-android",
    "com.google.android.exoplayer:exoplayer",
    "io.reactivex.rxjava3:rxjava",
    "javax.inject:javax.inject",
    "com.squareup.sqldelight:android-driver",
    "com.github.bumptech.glide:glide"
  )

// These are sort of inverse-facade dependencies. These may be seen as transitively-used
// dependencies that should be
// used via higher level facade dependency.
private val UP_CONVERT =
  mapOf(
    "androidx.arch.core:core-common" to "androidx.arch.core:core-runtime",
    "androidx.lifecycle:lifecycle-common" to "androidx.lifecycle:lifecycle-runtime"
  )

// These are dependencies we manage directly in SlackExtension
private val MANAGED_DEPENDENCIES = setOf<String>()

// These are projects that _only_ contain resources, which we can't properly handle yet until
// namespaced resources is
// available.
private val RESOURCE_ONLY_PROJECTS = setOf(":l10n-strings", ":slack-kit:slack-kit-resources")

private val String.group: String
  get() = substringBefore(":")

/** Returns if this is a facade dependency (only if it shares the same group). */
private fun String.isFacade(original: String = this): Boolean {
  return removeSuffix("-ktx") in FACADE_DEPENDENCIES && group == original.group
}

/**
 * Task that consumes the generated advice report json generated by `AdviceTask` and applies its
 * advice to the project build file. This is usually not run directly, but rather added as a
 * finalizer to the `AdviceTask` it reads from.
 */
internal abstract class RakeDependencies
@Inject
constructor(objects: ObjectFactory, providers: ProviderFactory) : AbstractPostProcessingTask() {

  @get:Input abstract val identifierMap: MapProperty<String, String>

  @get:PathSensitive(PathSensitivity.RELATIVE)
  @get:InputFile
  abstract val buildFileProperty: RegularFileProperty

  // We don't do ABI dependency cleanup yet, see
  // https://github.com/tinyspeck/slack-android-ng/issues/20315
  @get:Input
  val modes =
    objects
      .setProperty(AnalysisMode::class.java)
      .convention(
        providers
          .gradleProperty("slack.dependencyrake.modes")
          .map { it.splitToSequence(",").map(AnalysisMode::valueOf).toSet() }
          .orElse(
            setOf(
              AnalysisMode.COMPILE_ONLY,
              AnalysisMode.UNUSED,
              AnalysisMode.MISUSED,
              AnalysisMode.PLUGINS
            )
          )
      )

  @get:Input abstract val noApi: Property<Boolean>

  init {
    group = "rake"
  }

  @TaskAction
  fun rake() {
    val noApi = noApi.get()
    val comprehensiveAdvice = comprehensiveAdvice()
    val redundantPlugins = comprehensiveAdvice.pluginAdvice
    val advices =
      comprehensiveAdvice
        .dependencyAdvice
        .filterNot { advice ->
          // Don't add transitive dependencies of facade parents
          val isFacade =
            advice.isAdd() &&
              advice.parents.orEmpty().any { it.identifier.isFacade(advice.dependency.identifier) }
          if (isFacade) {
            logger.lifecycle("Not adding facaded dependency ${advice.dependency.identifier}")
          }
          isFacade
        }
        .filterNot { advice ->
          // Don't remove facade dependencies
          val isFacade = advice.isRemove() && advice.dependency.identifier.isFacade()
          if (isFacade) {
            logger.lifecycle("Not removing facade dependency ${advice.dependency.identifier}")
          }
          isFacade
        }
        .mapTo(LinkedHashSet()) { advice ->
          // Remap identifiers to their equivalent `libs.*` reference names.
          advice.copy(
            dependency = advice.dependency.copy(mapIdentifier(advice.dependency.identifier)),
            parents =
              advice.parents?.mapTo(mutableSetOf()) { it.copy(mapIdentifier(it.identifier)) },
            usedTransitiveDependencies =
              advice.usedTransitiveDependencies.mapTo(mutableSetOf()) {
                it.copy(mapIdentifier(it.identifier))
              }
          )
        }
    val buildFile = buildFileProperty.asFile.get()
    logger.lifecycle("🌲 Raking $buildFile")
    rakeProject(buildFile, advices, redundantPlugins, noApi)
  }

  @Suppress("LongMethod", "ComplexMethod")
  private fun rakeProject(
    buildFile: File,
    advices: Set<Advice>,
    redundantPlugins: Set<PluginAdvice>,
    noApi: Boolean
  ) {
    val resolvedModes = modes.get()
    val abiModeEnabled = AnalysisMode.ABI in resolvedModes

    val unusedDepsToRemove =
      if (AnalysisMode.UNUSED in resolvedModes) {
        advices.filter { it.isRemove() && it.usedTransitiveDependencies.isEmpty() }.associateBy {
          it.dependency.toDependencyString()
        }
      } else {
        emptyMap()
      }

    val misusedDepsToRemove =
      if (AnalysisMode.MISUSED in resolvedModes) {
        advices.filter { it.isRemove() && it.usedTransitiveDependencies.isNotEmpty() }.associateBy {
          it.dependency.toDependencyString()
        }
      } else {
        emptyMap()
      }

    val depsToRemove = unusedDepsToRemove + misusedDepsToRemove

    val depsToChange =
      if (AnalysisMode.ABI in resolvedModes) {
        advices.filter { it.isChange() }.associateBy { it.dependency.toDependencyString() }
      } else {
        emptyMap()
      }

    val depsToAdd =
      if (AnalysisMode.MISUSED in resolvedModes) {
        advices
          .filter { it.isAdd() }
          .filterNot { it.dependency.identifier in MANAGED_DEPENDENCIES }
          .associateBy { it.dependency.identifier }
          .toMutableMap()
      } else {
        mutableMapOf()
      }

    val compileOnlyDeps =
      if (AnalysisMode.COMPILE_ONLY in resolvedModes) {
        advices.filter { it.isCompileOnly() }.associateBy { it.dependency.toDependencyString() }
      } else {
        emptyMap()
      }

    // Now start rewriting the build file
    val newLines = mutableListOf<String>()
    buildFile.useLines { lines ->
      var inDependenciesBlock = false
      var done = false
      var ignoreNext = false
      lines.forEach { line ->
        if (done) {
          newLines += line
          return@forEach
        }
        if (!inDependenciesBlock) {
          if (line.trimStart().startsWith("dependencies {")) {
            inDependenciesBlock = true
          }
          newLines += line
          return@forEach
        } else {
          when {
            line.trimEnd() == "}" -> {
              done = true
              // Emit any remaining new dependencies to add
              depsToAdd
                .entries
                .map { (_, advice) ->
                  var newConfiguration = advice.toConfiguration!!
                  if (noApi && newConfiguration == "api") {
                    newConfiguration = "implementation"
                  } else if (!abiModeEnabled) {
                    newConfiguration = "implementation"
                  }
                  "  $newConfiguration(${advice.dependency.toDependencyNotation()})"
                }
                .sorted()
                .forEach {
                  logger.lifecycle("  ➕ Adding '${it.trimStart()}'")
                  newLines += it
                }

              newLines += line
              return@forEach
            }
            IGNORE_COMMENT in line -> {
              ignoreNext = true
              newLines += line
              return@forEach
            }
            ignoreNext -> {
              ignoreNext = false
              newLines += line
              return@forEach
            }
            depsToRemove.keys.any { it in line } -> {
              if (" {" in line) {
                logger.lifecycle("  🤔 Could not remove '$line'")
                newLines += line
                return@forEach
              }
              logger.lifecycle("  ⛔ Removing '${line.trimStart()}'")
              val (_, removed) = depsToRemove.entries.find { it.key in line }!!

              if (removed.dependency.identifier in RESOURCE_ONLY_PROJECTS) {
                newLines += line
              }

              // If this is being swapped with used transitives, inline them here
              // Note we remove from the depsToAdd list on a first come first serve bases (in case
              // multiple deps pull the same transitives).
              removed
                .usedTransitiveDependencies
                .mapNotNull { depsToAdd.remove(it.identifier) }
                .map { advice ->
                  val newConfiguration =
                    if (!abiModeEnabled) {
                      "implementation"
                    } else {
                      advice.toConfiguration
                    }
                  "  $newConfiguration(${advice.dependency.toDependencyNotation()})"
                }
                .sorted()
                .forEach { newLines += it }
              return@forEach
            }
            depsToChange.keys.any { it in line } || compileOnlyDeps.keys.any { it in line } -> {
              if (" {" in line) {
                logger.lifecycle("  🤔 Could not modify '$line'")
                newLines += line
                return@forEach
              }
              val which =
                if (depsToChange.keys.any { it in line }) depsToChange else compileOnlyDeps
              val (_, abiDep) =
                which.entries.first { it.value.dependency.toDependencyNotation() in line }
              val oldConfiguration = abiDep.fromConfiguration!!
              var newConfiguration = abiDep.toConfiguration!!
              if (noApi && newConfiguration == "api") {
                newConfiguration = "implementation"
              }
              // Replace the oldConfiguration name with API
              val newLine = line.replace("$oldConfiguration(", "$newConfiguration(")
              logger.lifecycle("  ✏️ Modifying configuration")
              logger.lifecycle("     -${line.trimStart()}")
              logger.lifecycle("     +${newLine.trimStart()}")
              newLines += newLine
              return@forEach
            }
            else -> {
              newLines += line
              return@forEach
            }
          }
        }
      }
    }

    if (AnalysisMode.PLUGINS in resolvedModes) {
      redundantPlugins.forEach { (id, reason) ->
        val lookFor =
          if (id.startsWith("org.jetbrains.kotlin.")) {
            "kotlin(\"${id.removePrefix("org.jetbrains.kotlin.")}\")"
          } else {
            "id(\"$id\")"
          }
        val pluginLine = newLines.indexOfFirst { lookFor == it.trim() }
        if (pluginLine != -1) {
          logger.lifecycle("Removing unused plugin \'$id\' in $buildFile. $reason")
          newLines.removeAt(pluginLine)
        }
      }
    }
    buildFile.writeText(newLines.cleanLineFormatting().joinToString("\n"))
  }

  /**
   * Maps a given [identifier] to a known toml lib reference or error if [error] is true.
   *
   * @param identifier the identifier to map, such as "com.squareup:kotlinpoet"
   * @param error if true, will throw an exception if the identifier is not found
   */
  private fun mapIdentifier(identifier: String, error: Boolean = false): String {
    return when {
      identifier.startsWith(":") -> {
        // Project dep
        identifier
      }
      else -> {
        UP_CONVERT[identifier]?.let {
          return mapIdentifier(it, error)
        }
        identifierMap.get()[identifier]
          ?: run {
            if (error) {
              error("Unknown identifier: $identifier")
            } else {
              logger.lifecycle("Unknown identifier: $identifier")
            }
            identifier
          }
      }
    }
  }

  private fun Dependency.toDependencyString(includeVersion: Boolean = true): String {
    return "$configurationName(${toDependencyNotation(includeVersion = includeVersion)})"
  }

  private fun Dependency.toDependencyNotation(includeVersion: Boolean = true): String {
    return when {
      "libs" in identifier -> {
        // Already mapped
        identifier
      }
      resolvedVersion == null -> {
        // Project dep
        "project(\"$identifier\")"
      }
      else -> {
        identifierMap.get()[identifier]
          ?: run {
            if (includeVersion) {
              "\"$identifier\""
            } else {
              "\"$identifier:$resolvedVersion\""
            }
          }
      }
    }
  }

  enum class AnalysisMode {
    /** Remove unused dependencies. */
    UNUSED,

    /** Modify dependencies that could be `compileOnly`. */
    COMPILE_ONLY,

    /** Fix dependencies that should be `api`. */
    ABI,

    /** Replace misused dependencies with their transitively-used dependencies. */
    MISUSED,

    /** Remove unused or redundant plugins. */
    PLUGINS
  }
}

private fun List<String>.cleanLineFormatting(): List<String> {
  val cleanedBlankLines = mutableListOf<String>()
  var blankLineCount = 0
  for (newLine in this) {
    if (newLine.isBlank()) {
      if (blankLineCount == 1) {
        // Skip this line
      } else {
        blankLineCount++
        cleanedBlankLines += newLine
      }
    } else {
      blankLineCount = 0
      cleanedBlankLines += newLine
    }
  }

  return cleanedBlankLines.padNewline()
}

private fun List<String>.padNewline(): List<String> {
  val noEmpties = dropLastWhile { it.isBlank() }
  return noEmpties + ""
}
