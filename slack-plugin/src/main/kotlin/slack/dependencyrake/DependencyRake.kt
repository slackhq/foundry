/*
 * Copyright (C) 2022 Slack Technologies, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package slack.dependencyrake

import com.autonomousapps.AbstractPostProcessingTask
import com.autonomousapps.advice.PluginAdvice
import com.autonomousapps.model.Advice
import com.autonomousapps.model.Coordinates
import com.autonomousapps.model.FlatCoordinates
import com.autonomousapps.model.IncludedBuildCoordinates
import com.autonomousapps.model.ModuleCoordinates
import com.autonomousapps.model.ProjectCoordinates
import java.io.File
import javax.inject.Inject
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property
import org.gradle.api.provider.ProviderFactory
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction
import slack.gradle.convertProjectPathToAccessor

private const val IGNORE_COMMENT = "// dependency-rake=ignore"

// These are dependencies we manage directly in SlackExtension
private val MANAGED_DEPENDENCIES = setOf<String>()

/**
 * Task that consumes the generated advice report json generated by `AdviceTask` and applies its
 * advice to the project build file. This is usually not run directly, but rather added as a
 * finalizer to the `AdviceTask` it reads from.
 */
internal abstract class RakeDependencies
@Inject
constructor(objects: ObjectFactory, providers: ProviderFactory) : AbstractPostProcessingTask() {

  @get:Input abstract val identifierMap: MapProperty<String, String>

  @get:PathSensitive(PathSensitivity.RELATIVE)
  @get:InputFile
  abstract val buildFileProperty: RegularFileProperty

  // We don't do ABI dependency cleanup yet, see
  // https://github.com/tinyspeck/slack-android-ng/issues/20315
  @get:Input
  val modes =
    objects
      .setProperty(AnalysisMode::class.java)
      .convention(
        providers
          .gradleProperty("slack.dependencyrake.modes")
          .map { it.splitToSequence(",").map(AnalysisMode::valueOf).toSet() }
          .orElse(
            setOf(
              AnalysisMode.COMPILE_ONLY,
              AnalysisMode.UNUSED,
              AnalysisMode.MISUSED,
              AnalysisMode.PLUGINS
            )
          )
      )

  @get:Input abstract val noApi: Property<Boolean>

  init {
    group = "rake"
  }

  @TaskAction
  fun rake() {
    val noApi = noApi.get()
    val projectAdvice = projectAdvice()
    val redundantPlugins = projectAdvice.pluginAdvice
    val advices: Set<Advice> =
      projectAdvice.dependencyAdvice.mapTo(LinkedHashSet()) { advice ->
        // Remap identifiers to their equivalent `libs.*` reference names.
        advice.copy(
          coordinates = advice.coordinates.mapIdentifier(),
        )
      }
    val buildFile = buildFileProperty.asFile.get()
    logger.lifecycle("🌲 Raking $buildFile")
    rakeProject(buildFile, advices, redundantPlugins, noApi)
  }

  @Suppress("LongMethod", "ComplexMethod")
  private fun rakeProject(
    buildFile: File,
    advices: Set<Advice>,
    redundantPlugins: Set<PluginAdvice>,
    noApi: Boolean
  ) {
    val resolvedModes = modes.get()
    val abiModeEnabled = AnalysisMode.ABI in resolvedModes

    val unusedDepsToRemove =
      if (AnalysisMode.UNUSED in resolvedModes) {
        advices.filter { it.isRemove() }.associateBy { it.toDependencyString() }
      } else {
        emptyMap()
      }

    val misusedDepsToRemove =
      if (AnalysisMode.MISUSED in resolvedModes) {
        advices.filter { it.isRemove() }.associateBy { it.toDependencyString() }
      } else {
        emptyMap()
      }

    val depsToRemove = unusedDepsToRemove + misusedDepsToRemove

    val depsToChange =
      if (AnalysisMode.ABI in resolvedModes) {
        advices.filter { it.isChange() }.associateBy { it.toDependencyString() }
      } else {
        emptyMap()
      }

    val depsToAdd =
      if (AnalysisMode.MISUSED in resolvedModes) {
        advices
          .filter { it.isAdd() }
          .filterNot { it.coordinates.identifier in MANAGED_DEPENDENCIES }
          .associateBy { it.coordinates.identifier }
          .toMutableMap()
      } else {
        mutableMapOf()
      }

    val compileOnlyDeps =
      if (AnalysisMode.COMPILE_ONLY in resolvedModes) {
        advices.filter { it.isCompileOnly() }.associateBy { it.toDependencyString() }
      } else {
        emptyMap()
      }

    // Now start rewriting the build file
    val newLines = mutableListOf<String>()
    buildFile.useLines { lines ->
      var inDependenciesBlock = false
      var done = false
      var ignoreNext = false
      lines.forEach { line ->
        if (done) {
          newLines += line
          return@forEach
        }
        if (!inDependenciesBlock) {
          if (line.trimStart().startsWith("dependencies {")) {
            inDependenciesBlock = true
          }
          newLines += line
          return@forEach
        } else {
          when {
            line.trimEnd() == "}" -> {
              done = true
              // Emit any remaining new dependencies to add
              depsToAdd
                .entries
                .map { (_, advice) ->
                  var newConfiguration = advice.toConfiguration!!
                  if (noApi && newConfiguration == "api") {
                    newConfiguration = "implementation"
                  } else if (!abiModeEnabled) {
                    newConfiguration = "implementation"
                  }
                  "  $newConfiguration(${advice.coordinates.toDependencyNotation()})"
                }
                .sorted()
                .forEach {
                  logger.lifecycle("  ➕ Adding '${it.trimStart()}'")
                  newLines += it
                }

              newLines += line
              return@forEach
            }
            IGNORE_COMMENT in line -> {
              ignoreNext = true
              newLines += line
              return@forEach
            }
            ignoreNext -> {
              ignoreNext = false
              newLines += line
              return@forEach
            }
            depsToRemove.keys.any { it in line } -> {
              if (" {" in line) {
                logger.lifecycle("  🤔 Could not remove '$line'")
                newLines += line
                return@forEach
              }
              logger.lifecycle("  ⛔ Removing '${line.trimStart()}'")

              // If this is being swapped with used transitives, inline them here
              // Note we remove from the depsToAdd list on a first-come-first-serve bases (in case
              // multiple deps pull the same transitives).
              advices
                .filter { it.isAdd() }
                .mapNotNull { depsToAdd.remove(it.coordinates.identifier) }
                .map { advice ->
                  val newConfiguration =
                    if (!abiModeEnabled) {
                      "implementation"
                    } else {
                      advice.toConfiguration
                    }
                  "  $newConfiguration(${advice.coordinates.toDependencyNotation()})"
                }
                .sorted()
                .forEach { newLines += it }
              return@forEach
            }
            depsToChange.keys.any { it in line } || compileOnlyDeps.keys.any { it in line } -> {
              if (" {" in line) {
                logger.lifecycle("  🤔 Could not modify '$line'")
                newLines += line
                return@forEach
              }
              val which =
                if (depsToChange.keys.any { it in line }) depsToChange else compileOnlyDeps
              val (_, abiDep) =
                which.entries.first { it.value.coordinates.toDependencyNotation() in line }
              val oldConfiguration = abiDep.fromConfiguration!!
              var newConfiguration = abiDep.toConfiguration!!
              if (noApi && newConfiguration == "api") {
                newConfiguration = "implementation"
              }
              // Replace the oldConfiguration name with API
              val newLine = line.replace("$oldConfiguration(", "$newConfiguration(")
              logger.lifecycle("  ✏️ Modifying configuration")
              logger.lifecycle("     -${line.trimStart()}")
              logger.lifecycle("     +${newLine.trimStart()}")
              newLines += newLine
              return@forEach
            }
            else -> {
              newLines += line
              return@forEach
            }
          }
        }
      }
    }

    if (AnalysisMode.PLUGINS in resolvedModes) {
      redundantPlugins.forEach { (id, reason) ->
        val lookFor =
          if (id.startsWith("org.jetbrains.kotlin.")) {
            "kotlin(\"${id.removePrefix("org.jetbrains.kotlin.")}\")"
          } else {
            "id(\"$id\")"
          }
        val pluginLine = newLines.indexOfFirst { lookFor == it.trim() }
        if (pluginLine != -1) {
          logger.lifecycle("Removing unused plugin \'$id\' in $buildFile. $reason")
          newLines.removeAt(pluginLine)
        }
      }
    }
    buildFile.writeText(newLines.cleanLineFormatting().joinToString("\n"))
  }

  /**
   * Remaps a given [Coordinates] to a known toml lib reference or error if [error] is true.
   *
   * @param error if true, will throw an exception if the identifier is not found
   */
  private fun Coordinates.mapIdentifier(error: Boolean = false): Coordinates {
    return when (this) {
      is ProjectCoordinates -> this
      is ModuleCoordinates -> {
        val newIdentifier =
          identifierMap.get()[identifier]
            ?: run {
              if (error) {
                error("Unknown identifier: $identifier")
              } else {
                logger.lifecycle("Unknown identifier: $identifier")
              }
              return this@mapIdentifier
            }
        ModuleCoordinates(newIdentifier, resolvedVersion)
      }
      is FlatCoordinates -> this
      is IncludedBuildCoordinates -> this
    }
  }

  private fun Advice.toDependencyString(): String {
    return "${fromConfiguration ?: error("Transitive dep $this")}(${coordinates.toDependencyNotation()})"
  }

  private fun Coordinates.toDependencyNotation(): String {
    return when (this) {
      is ProjectCoordinates -> "projects.${convertProjectPathToAccessor(identifier)}"
      is ModuleCoordinates -> identifier // already mapped
      is FlatCoordinates -> gav()
      is IncludedBuildCoordinates -> gav()
    }
  }

  enum class AnalysisMode {
    /** Remove unused dependencies. */
    UNUSED,

    /** Modify dependencies that could be `compileOnly`. */
    COMPILE_ONLY,

    /** Fix dependencies that should be `api`. */
    ABI,

    /** Replace misused dependencies with their transitively-used dependencies. */
    MISUSED,

    /** Remove unused or redundant plugins. */
    PLUGINS
  }
}

private fun List<String>.cleanLineFormatting(): List<String> {
  val cleanedBlankLines = mutableListOf<String>()
  var blankLineCount = 0
  for (newLine in this) {
    if (newLine.isBlank()) {
      if (blankLineCount == 1) {
        // Skip this line
      } else {
        blankLineCount++
        cleanedBlankLines += newLine
      }
    } else {
      blankLineCount = 0
      cleanedBlankLines += newLine
    }
  }

  return cleanedBlankLines.padNewline()
}

private fun List<String>.padNewline(): List<String> {
  val noEmpties = dropLastWhile { it.isBlank() }
  return noEmpties + ""
}
